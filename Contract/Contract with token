// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract SmartBondToken is ERC20 {
    // 1. Variables
    address public issuer;
    uint256 public maturityDate;
    uint256 public principalAmount;
    uint256 public couponFrequency;
    uint256 public couponAmount;
    uint256 public lastCouponPaymentTime;
    uint256 public valuePerToken; // The fixed value per token in Wei (1 Ether = 1e18 Wei)

    // 2. Events
    event CouponPayment(address indexed recipient, uint256 amount);
    event MaturityReached();
    event Redemption(address indexed recipient, uint256 amount);

    // 3. Constructor
    constructor(
        string memory name,
        string memory symbol,
        uint256 _totalSupply,
        uint256 _maturity, // Maturity specified in minutes
        uint256 _principalAmount,
        uint256 _couponFrequency, // Coupon frequency specified in minutes
        uint256 _couponAmount,
        uint256 _valueInWeiPerToken // Specify the fixed value in Wei
    ) ERC20(name, symbol) {
        issuer = msg.sender;

        // Convert maturity from minutes to seconds
        maturityDate = block.timestamp + _maturity * 1 minutes;

        principalAmount = _principalAmount;
        couponFrequency = _couponFrequency;
        couponAmount = _couponAmount;
        lastCouponPaymentTime = block.timestamp;
        valuePerToken = _valueInWeiPerToken;
        
        _mint(msg.sender, _totalSupply);
    }

    // 4. Functions
    function buyTokens(uint256 numTokens) external payable {
        require(msg.value == numTokens * valuePerToken, "Incorrect payment amount");
        _mint(msg.sender, numTokens);
    }

    function sellTokens(uint256 numTokens) external {
        require(balanceOf(msg.sender) >= numTokens, "Insufficient balance");
        _burn(msg.sender, numTokens);
        payable(msg.sender).transfer(numTokens * valuePerToken);
    }

    function payCoupon() external {
        require(block.timestamp >= lastCouponPaymentTime + couponFrequency * 1 minutes, "Coupon not due yet");
        uint256 issuerBalance = balanceOf(issuer);
        
        // Check if the issuer's balance is sufficient to cover all coupon payments
        require(issuerBalance >= totalSupply() * couponAmount, "Insufficient balance for coupon payments");

        // Store token holders separately or use a mapping to track them
        address[] memory holders = new address[](totalSupply());
        for (uint256 i = 0; i < totalSupply(); i++) {
            holders[i] = tokenByIndex(i);
        }

        // Iterate through token holders and pay coupon to each eligible holder
        for (uint256 i = 0; i < holders.length; i++) {
            address holder = holders[i];
            uint256 balance = balanceOf(holder);
            if (balance >= couponAmount) {
                transfer(holder, couponAmount);
                emit CouponPayment(holder, couponAmount);
            }
        }

        lastCouponPaymentTime = block.timestamp;
    }

    function isMatured() public view returns (bool) {
        return block.timestamp >= maturityDate;
    }

    function redeem() external { // automatically redeem bond if matured after checking maturity function
        require(isMatured(), "Bond has not matured yet");
        require(msg.sender == issuer, "Only the issuer can redeem the bond");

        uint256 balance = balanceOf(msg.sender); // Get the bondholder's balance
        require(balance >= principalAmount, "Insufficient balance for redemption");

        _burn(msg.sender, principalAmount); // Burn the bond tokens from the bondholder
        payable(msg.sender).transfer(principalAmount); // Transfer the principal to the bondholder

        emit Redemption(msg.sender, principalAmount); // Emit the Redemption event for the bondholder
    }
}
